//-----------------------------------------------------------------------------
// <auto-generated>
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated.
//
//   For more information, see: http://go.microsoft.com/fwlink/?LinkID=623246
// </auto-generated>
//-----------------------------------------------------------------------------
#include "pch.h"

using namespace concurrency;
using namespace Microsoft::WRL;
using namespace Platform;
using namespace Windows::Foundation;
using namespace Windows::Foundation::Collections;
using namespace Windows::Devices::AllJoyn;
using namespace com::ooeygui::remotecontrolvehicle;
namespace com { namespace ooeygui { namespace remotecontrolvehicle {

// Methods
remotecontrolvehicleGetAnalogChannelDataCalledEventArgs::remotecontrolvehicleGetAnalogChannelDataCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ uint32 interfaceMemberChannelId)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberChannelId(interfaceMemberChannelId)
{
    m_result = remotecontrolvehicleGetAnalogChannelDataResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ remotecontrolvehicleGetAnalogChannelDataCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &remotecontrolvehicleGetAnalogChannelDataCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void remotecontrolvehicleGetAnalogChannelDataCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void remotecontrolvehicleGetAnalogChannelDataCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void remotecontrolvehicleGetAnalogChannelDataCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for GetAnalogChannelDataCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

remotecontrolvehicleSetAnalogChannelStateCalledEventArgs::remotecontrolvehicleSetAnalogChannelStateCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ uint32 interfaceMemberChannelId,
    _In_ double interfaceMemberValue)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberChannelId(interfaceMemberChannelId),
    m_interfaceMemberValue(interfaceMemberValue)
{
    m_result = remotecontrolvehicleSetAnalogChannelStateResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ remotecontrolvehicleSetAnalogChannelStateCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &remotecontrolvehicleSetAnalogChannelStateCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void remotecontrolvehicleSetAnalogChannelStateCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void remotecontrolvehicleSetAnalogChannelStateCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void remotecontrolvehicleSetAnalogChannelStateCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for SetAnalogChannelStateCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

remotecontrolvehicleSetToggleChannelStateCalledEventArgs::remotecontrolvehicleSetToggleChannelStateCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ uint32 interfaceMemberChannelId,
    _In_ uint32 interfaceMemberValue)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberChannelId(interfaceMemberChannelId),
    m_interfaceMemberValue(interfaceMemberValue)
{
    m_result = remotecontrolvehicleSetToggleChannelStateResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ remotecontrolvehicleSetToggleChannelStateCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &remotecontrolvehicleSetToggleChannelStateCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void remotecontrolvehicleSetToggleChannelStateCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void remotecontrolvehicleSetToggleChannelStateCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void remotecontrolvehicleSetToggleChannelStateCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for SetToggleChannelStateCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

remotecontrolvehicleSetMultipleAnalogChannelStatesCalledEventArgs::remotecontrolvehicleSetMultipleAnalogChannelStatesCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Windows::Foundation::Collections::IVectorView<uint32>^ interfaceMemberChannelIds,
    _In_ Windows::Foundation::Collections::IVectorView<double>^ interfaceMemberValues)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberChannelIds(interfaceMemberChannelIds),
    m_interfaceMemberValues(interfaceMemberValues)
{
    m_result = remotecontrolvehicleSetMultipleAnalogChannelStatesResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ remotecontrolvehicleSetMultipleAnalogChannelStatesCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &remotecontrolvehicleSetMultipleAnalogChannelStatesCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void remotecontrolvehicleSetMultipleAnalogChannelStatesCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void remotecontrolvehicleSetMultipleAnalogChannelStatesCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void remotecontrolvehicleSetMultipleAnalogChannelStatesCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for SetMultipleAnalogChannelStatesCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

// Readable Properties
remotecontrolvehicleGetReceiverNameRequestedEventArgs::remotecontrolvehicleGetReceiverNameRequestedEventArgs(
    _In_ AllJoynMessageInfo^ info)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info)
{
    m_result = remotecontrolvehicleGetReceiverNameResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ remotecontrolvehicleGetReceiverNameRequestedEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &remotecontrolvehicleGetReceiverNameRequestedEventArgs::Complete);
    return ref new Deferral(handler);
}

void remotecontrolvehicleGetReceiverNameRequestedEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void remotecontrolvehicleGetReceiverNameRequestedEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void remotecontrolvehicleGetReceiverNameRequestedEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for GetReceiverNameRequested.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

remotecontrolvehicleGetManufacturerRequestedEventArgs::remotecontrolvehicleGetManufacturerRequestedEventArgs(
    _In_ AllJoynMessageInfo^ info)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info)
{
    m_result = remotecontrolvehicleGetManufacturerResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ remotecontrolvehicleGetManufacturerRequestedEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &remotecontrolvehicleGetManufacturerRequestedEventArgs::Complete);
    return ref new Deferral(handler);
}

void remotecontrolvehicleGetManufacturerRequestedEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void remotecontrolvehicleGetManufacturerRequestedEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void remotecontrolvehicleGetManufacturerRequestedEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for GetManufacturerRequested.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

remotecontrolvehicleGetDeviceTypeRequestedEventArgs::remotecontrolvehicleGetDeviceTypeRequestedEventArgs(
    _In_ AllJoynMessageInfo^ info)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info)
{
    m_result = remotecontrolvehicleGetDeviceTypeResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ remotecontrolvehicleGetDeviceTypeRequestedEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &remotecontrolvehicleGetDeviceTypeRequestedEventArgs::Complete);
    return ref new Deferral(handler);
}

void remotecontrolvehicleGetDeviceTypeRequestedEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void remotecontrolvehicleGetDeviceTypeRequestedEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void remotecontrolvehicleGetDeviceTypeRequestedEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for GetDeviceTypeRequested.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

remotecontrolvehicleGetChannelsRequestedEventArgs::remotecontrolvehicleGetChannelsRequestedEventArgs(
    _In_ AllJoynMessageInfo^ info)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info)
{
    m_result = remotecontrolvehicleGetChannelsResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ remotecontrolvehicleGetChannelsRequestedEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &remotecontrolvehicleGetChannelsRequestedEventArgs::Complete);
    return ref new Deferral(handler);
}

void remotecontrolvehicleGetChannelsRequestedEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void remotecontrolvehicleGetChannelsRequestedEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void remotecontrolvehicleGetChannelsRequestedEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for GetChannelsRequested.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

// Writable Properties
} } } 
